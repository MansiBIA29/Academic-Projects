# -*- coding: utf-8 -*-
"""Demo

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TjK7UasAhlFBn_VS3VUWny0bVUTYPWSi
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.holtwinters import ExponentialSmoothing
from sklearn.metrics import mean_squared_error, mean_absolute_error
from prophet import Prophet

# Set page title
st.title('Time Series Analysis and Forecasting Tool')

# Data upload section
st.subheader('Data Upload')
uploaded_file = st.file_uploader("Upload CSV file", type=["csv"])

ts_data = None

if uploaded_file is not None:
    try:
        data = pd.read_csv(uploaded_file)
        st.write("Data Preview:")
        st.dataframe(data.head())

        # Select date and value columns
        st.subheader('Select Columns')
        date_column = st.selectbox('Select Date Column', data.columns)
        value_column = st.selectbox('Select Value Column', data.columns)

        try:
            data[date_column] = pd.to_datetime(data[date_column])
            data = data.set_index(date_column)
        except:
            st.error('Could not convert the selected column to datetime. Please choose a valid date column.')
            st.stop()

        st.subheader('Data Resampling')
        resample_choice = st.selectbox('Select Resampling Frequency', ['None', 'Daily', 'Weekly', 'Monthly'])

        if resample_choice != 'None':
            if resample_choice == 'Daily':
                data = data.resample('D').mean()
            elif resample_choice == 'Weekly':
                data = data.resample('W').mean()
            else:
                data = data.resample('M').mean()

            data = data.fillna(method='ffill')

        ts_data = data[value_column]

        st.subheader('Time Series Data')
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.plot(ts_data)
        ax.set_title('Time Series Data')
        ax.set_xlabel('Date')
        ax.set_ylabel(value_column)
        plt.xticks(rotation=45)
        plt.tight_layout()
        st.pyplot(fig)

    except Exception as e:
        st.error(f"Error processing data: {e}")

if ts_data is not None:
    st.subheader('Time Series Decomposition')
    decomposition_type = st.selectbox('Choose decomposition type', ['Additive', 'Multiplicative'])
    period = st.slider('Select seasonality period', 2, min(52, len(ts_data) // 2), 12)

    try:
        if decomposition_type == 'Additive':
            decomposition = seasonal_decompose(ts_data, model='additive', period=period)
        else:
            decomposition = seasonal_decompose(ts_data, model='multiplicative', period=period)

        fig, (ax1, ax2, ax3, ax4) = plt.subplots(4, 1, figsize=(10, 12))
        ax1.plot(decomposition.observed); ax1.set_title('Observed')
        ax2.plot(decomposition.trend); ax2.set_title('Trend')
        ax3.plot(decomposition.seasonal); ax3.set_title('Seasonality')
        ax4.plot(decomposition.resid); ax4.set_title('Residuals')
        plt.tight_layout()
        st.pyplot(fig)
    except:
        st.error(f"Could not perform decomposition. Try a different period (current: {period}).")

    st.subheader('Time Series Forecasting')
    value_column = ts_data.name if ts_data.name is not None else 'Value'
    train_size = st.slider('Training data %', 50, 90, 80)
    train_size = int(len(ts_data) * train_size / 100)
    train_data = ts_data[:train_size]
    test_data = ts_data[train_size:]

    st.write(f'Training data: {train_data.shape[0]} records')
    st.write(f'Testing data: {test_data.shape[0]} records')

    model_choice = st.selectbox('Choose a forecasting model', ['ARIMA', 'ETS', 'Prophet'])

    def calculate_metrics(actual, predicted):
        mse = mean_squared_error(actual, predicted)
        rmse = np.sqrt(mse)
        mae = mean_absolute_error(actual, predicted)
        mape = np.mean(np.abs((actual - predicted) / np.maximum(actual, 1e-10))) * 100
        return {'MSE': mse, 'RMSE': rmse, 'MAE': mae, 'MAPE': mape}

    forecast = None
    metrics = {}

    if model_choice == 'ARIMA':
        st.write('ARIMA Parameters:')
        p = st.slider('p (AR order)', 0, 5, 1)
        d = st.slider('d (Differencing)', 0, 2, 1)
        q = st.slider('q (MA order)', 0, 5, 1)

        with st.spinner('Fitting ARIMA model...'):
            try:
                model = ARIMA(train_data, order=(p, d, q))
                model_fit = model.fit()
                forecast = model_fit.forecast(steps=len(test_data))
                metrics = calculate_metrics(test_data.values, forecast)
            except Exception as e:
                st.error(f'Error fitting ARIMA model: {e}. Try different parameters.')
                st.stop()

    elif model_choice == 'ETS':
        st.write('ETS Parameters:')
        trend_type = st.selectbox('Trend type', ['add', 'mul', None])
        seasonal_type = st.selectbox('Seasonal type', ['add', 'mul', None])

        with st.spinner('Fitting ETS model...'):
            try:
                model = ExponentialSmoothing(
                    train_data,
                    trend=trend_type,
                    seasonal=seasonal_type,
                    seasonal_periods=period if seasonal_type is not None else None
                )
                model_fit = model.fit()
                forecast = model_fit.forecast(steps=len(test_data))
                metrics = calculate_metrics(test_data.values, forecast)
            except Exception as e:
                st.error(f'Error fitting ETS model: {e}. Try different parameters.')
                st.stop()

    elif model_choice == 'Prophet':
        st.write('Prophet uses additive regression with trend & seasonality')
        with st.spinner('Fitting Prophet model...'):
            try:
                prophet_df = pd.DataFrame({'ds': ts_data.index, 'y': ts_data.values})
                train_df = prophet_df[:train_size]
                test_df = prophet_df[train_size:]

                model = Prophet()
                model.fit(train_df)

                future = model.make_future_dataframe(periods=len(test_df), freq='D' if resample_choice == 'Daily'
                                                     else 'W' if resample_choice == 'Weekly'
                                                     else 'M' if resample_choice == 'Monthly'
                                                     else 'D')
                forecast_df = model.predict(future)
                forecast = forecast_df.iloc[train_size:]['yhat'].values
                metrics = calculate_metrics(test_df['y'].values, forecast)

                st.write(model.plot(forecast_df))
                st.pyplot()
            except Exception as e:
                st.error(f'Error fitting Prophet model: {e}')
                st.stop()

    st.subheader('Forecast Metrics')
    if metrics:
        metrics_df = pd.DataFrame({
            'Metric': list(metrics.keys()),
            'Value': list(metrics.values())
        })
        st.table(metrics_df)
    else:
        st.warning("No metrics available. Please ensure a model has been successfully fitted.")

    if forecast is not None:
        st.subheader('Forecast Results')
        fig, ax = plt.subplots(figsize=(10, 6))
        ax.plot(train_data.index, train_data, label='Training Data')
        ax.plot(test_data.index, test_data, label='Actual Test Data')
        ax.plot(test_data.index, forecast, label='Forecast')
        ax.set_title('Forecast vs Actual')
        ax.set_xlabel('Date')
        ax.set_ylabel(value_column)
        ax.legend()
        plt.xticks(rotation=45)
        plt.tight_layout()
        st.pyplot(fig)